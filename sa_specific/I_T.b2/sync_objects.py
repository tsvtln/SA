#!/opt/opsware/bin/python2
#                      -*- Mode: Python ; tab-width: 4 -*- 

# This script takes the output of table_checker.py --simple and synchronizes each
# object across all cores in a mesh.  Objects are not synchronized in a logical order,
# so foreign-key constraints may happen.  Run it again if they do.

# One type of ordering is enforced, though:  certain tables must be sync'd after others.
# For example, AimDependentElement is populated by a trigger.  Since the trigger
# is not idempotent, we don't want to insert an AimDependentElement and then insert another
# object that fires the trigger to re-insert the same AimDependentElement.

# This script will only work in Babbage and later installations.

import sys
import os
import string
import getopt
import types
import time
import traceback
import shutil
import tempfile
import threading
try:
	import warnings
	# Disable DeprecationWarnings
	warnings.simplefilter('ignore', DeprecationWarning)
except ImportError:
	pass


sys.path.append( "/lc/blackshadow" )
sys.path.append( "/cust/usr/blackshadow" )
sys.path.append( "/cust/usr/blackshadow/spin" )
sys.path.append( "/opt/opsware/corelibs" )
sys.path.append( "/cust/ldapmodule" )
sys.path.append( "/opt/opsware" )
sys.path.append( "/opt/opsware/spin" )
if (sys.version[0] == "2"):
	sys.path.append( "/opt/opsware/pylibs2" )
else:
	sys.path.append( "/opt/opsware/pylibs" )
sys.path.append( "/soft/blackshadow/spin" )# For development
if not os.environ.has_key( "SPIN_DIR" ):
	os.environ["SPIN_DIR"] = "/cust/usr/blackshadow/spin"
try:
	import truthdb
	import spinobj
	import truthtable
	import spinconf
	import multimaster
	from spinerror import *
except ImportError:
	sys.stderr.write( "Unable to import Data Access Engine libraries: %s, %s.  Is the Data Access Engine installed on this host?\n" % sys.exc_info()[0:2] )
	sys.exit( 1 )


method = "multimaster.forcefulResolver()"
default_threads = 1

# See above about trigger-related ordering.
# This is a mapping from class name to order.  Classes not listed get order 0.
# Classes with equal orders are synchronized in the approximate order supplied,
# depending on the number of threads you use.
class_order = {
	"AimDependentElement" : 1,
	}


def usage():
	
	sys.stderr.write( """Usage:  sync_objects.py [--sql] [--from <core-id>] [-t <num>] [--fails fails_file] [tc_out_file]
  --sql = Print out SQL as it's executed.
  --from <core-id> = Sync transactions from the specified core instead of
     the core of origin of each object.  Because some objects have
     non-numeric IDs, the core of origin can't always be determined.
     If objects like this are included, --from must be specified.
  -t <num> = The number of threads to use when synchronizing.
  --fails <fails_file> = Write a new table_checker output file containing just those objects that failed synchronization.
  tc_out_file = An output file generated by table_checker.py --simple.  If not supplied, objects are read one per line from stdin.\n""" )
	sys.exit( 1 )


def main():

	try:
		(odict, args) = getOptions()
	except getopt.error:
		sys.stderr.write( str(sys.exc_info()[1]) + "\n" )
		usage()
		
	# We do this here so that problems are reported after usage errors.
	import init

	user = os.environ.get("USER", os.environ.get("LOGNAME", "root"))
	
	if odict.has_key( "sql" ):
		truthdb.debug = 1

	if args:
		fname = args[0]
	else:
		fname = None

	fails = syncFileContents( user, fname, odict["from"], odict["t"], odict.get("fails") )

	sys.exit( fails )
	

def syncFileContents( user, tc_out_file, from_core_id = None, n = default_threads, new_out_file = None ):

	if tc_out_file:
		f = open( tc_out_file )
		ll = map( string.strip, f.readlines() )
		f.close()
	else:
		ll = map( string.strip, sys.stdin.readlines() )

	objects = []
	for l in ll:
		objects.append( string.split( l, None, 1 ) )
	
	fails = syncObjects( user, objects, from_core_id, n )

	if fails and new_out_file:
		f = open( new_out_file, "w" )
		for (cls, id) in fails:
			f.write( "%s %s\n" % (cls, id) )
		f.close()

	return len(fails)


# 'objects' is a list of lists:  [[<obj_class>, <id>], ...]
def syncObjects( user, objects, from_core_id = None, n = default_threads ):

	all_dcs = multimaster.getAllDCs( method, user )
	if (from_core_id != None) and not all_dcs.has_key( from_core_id ):
		print "ERROR:  '--from %s' does not correspond to an existing core." % (from_core_id)
		return 1

	print "Synchronizing %s objects..." % (len(objects))

	orderedObjects = orderObjects( objects )
	
	i = 0
	all_count = len(objects)
	fails = []
	for objects in orderedObjects:
		print "Synchronizing %s objects in pass %d..." % (len(objects), i)
		branchThreads( n, syncThread, (user, all_dcs, objects, fails, from_core_id) )
		i = i + 1
	
	print "Done.  %s succeeded, %s failed." % (all_count - len(fails), len(fails))
	return fails


def orderObjects( objects ):

	orders = {}
	for (obj_class, obj_id) in objects:
		order = class_order.get( obj_class, 0 )
		if not orders.has_key( order ):
			orders[order] = []
		orders[order].append( (obj_class, obj_id) )

	orderedObjects = []
	kk = orders.keys()
	kk.sort()
	for k in kk:
		orderedObjects.append( orders[k] )

	return orderedObjects


# This function is destructive to 'objects'.  Caller beware.
def syncThread( user, all_dcs, objects, fails, from_core_id = None ):

	while 1:

		try:
			(obj_class, obj_id) = objects.pop( 0 )
		except IndexError:
			break

		# Sync the object from the core of origin or the specified core
		# regardless of what the diffs are.  POW!
		if (from_core_id == None):
			core_id = getCoreIDFromObject( obj_class, obj_id, fails )
			if not core_id:
				continue
			if not all_dcs.has_key( core_id ):
				msg = "%s %s has an ID from a core that doesn't exist:  --from must be specified." % (obj_class, obj_id)
				handleError( obj_class, obj_id, fails, [msg] )
				continue
		else:
			core_id = from_core_id
		sys.stdout.write( "%s Sync %s %s from %s...\n" % ((time.strftime("%Y-%m-%d_%H:%M:%S",time.gmtime(time.time()))), obj_class, obj_id, truthdb.longAsString(core_id)) )
		sync = multimaster.syncObject( user, obj_class, obj_id, core_id, all_dcs=all_dcs )

		# If the sync succeeded, mark it resolved
		if sync["error"]:
			errs = []
			for d in sync["actions"]:
				if d["error"]:
					errs.append( "At %s:  %s (%s)" % (truthdb.longAsString(d["core_id"]),
													  d["error_name"], d["error_msg"]) )
			handleError( obj_class, obj_id, fails, errs )
		else:
			sys.stdout.write( "%s %s OK.\n" % (obj_class, obj_id) )


def getCoreIDFromObject( obj_class, obj_id, fails ):

	cls = spinobj.getObjectClass( obj_class )
	if hasattr( cls, "compound_id_delimiter" ):
		delimiter = cls.compound_id_delimiter
	else:
		delimiter = "-"
	if (type(obj_id) == types.StringType) and (delimiter in obj_id):
		# Compound ID.  At least one part must be a globalized ID.
		# If more than one part is a globalized ID, all must be from the same core.
		found_core_id = None
		for id_part in string.split( obj_id, delimiter ):
			try:
				(seq, core_id) = truthdb.parseGlobalID( id_part )
				if seq:
					if found_core_id and (core_id != found_core_id):
						msg = "%s %s has ID parts originating from different cores:  --from must be specified." % (obj_class, obj_id)
						handleError( obj_class, obj_id, fails, [msg] )
						return None
					found_core_id = core_id
			except ValueError:
				pass
		if found_core_id:
			return found_core_id
		else:
			msg = "%s %s has no ID part that is globalized:  --from must be specified." % (obj_class, obj_id)
			handleError( obj_class, obj_id, fails, [msg] )
			return None
			
	else:
		try:
			(seq, core_id) = truthdb.parseGlobalID( obj_id )
			if seq:
				return core_id
			else:
				msg = "%s %s has a non-globalized ID:  --from must be specified." % (obj_class, obj_id)
				handleError( obj_class, obj_id, fails, [msg] )
				return None
		except ValueError:
			msg = "%s %s has a non-numeric ID:  --from must be specified." % (obj_class, obj_id)
			handleError( obj_class, obj_id, fails, [msg] )
			return None
			

def handleError( obj_class, obj_id, fails, errs ):
	
	ll = ["%s %s Failed:" % (obj_class, obj_id)]
	for err in errs:
		if (len(err) > 120):
			err = err[:120] + "..."
		ll.append( "    " + err )
	sys.stdout.write( string.join( ll, "\n" ) )
	sys.stdout.write( "\n" )
	fails.append( (obj_class, obj_id) )


def branchThreads( n, f, args ):

	# Never mind if there's only going to be one thread
	if (n == 1):
		apply( f, args )

	else:
		threads = []
		for tid in range(n):
			thread = threading.Thread( target=f, args=args )
			threads.append( thread )
			thread.start()
		for thread in threads:
			thread.join()


def getOptions():

	(tt, args) = getopt.getopt( sys.argv[1:], "t:", ["sql", "from=", "fails="] )
	odict = {}
	for t in tt:
		s = t[0]
		while (s[0] == "-"):		# Strip leading '-'s
			s = s[1:]
		if not odict.has_key( s ):
			odict[s] = []
		odict[s] = t[1]

	if odict.has_key( "from" ):
		odict["from"] = int( odict["from"] )
	else:
		odict["from"] = None

	odict["t"] = int( odict.get( "t", default_threads ) )

	return (odict, args)


#------------------------------------------------------------------------------
if __name__ == "__main__":
#------------------------------------------------------------------------------
	main ( )


